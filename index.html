<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Quiz IA ‚Äì Revis√£o VA2 (SQL)</title>
<style>
  :root {
    --bg:#0f1724; --card:#0b1320; --muted:#94a3b8; --accent:#0ea5a4;
    --success:#16a34a; --danger:#ef4444; --neutral:#e6eef6;
    --glass:rgba(255,255,255,0.05);
    font-family: 'Inter', system-ui, sans-serif;
  }

  html, body {
    margin:0; padding:0;
    background: radial-gradient(ellipse at top left, rgba(14,165,164,0.08), transparent 20%),
                linear-gradient(180deg, #071225, #07192a);
    color: var(--neutral);
    -webkit-font-smoothing: antialiased;
    min-height:100vh;
  }

  .container {
    max-width: 980px;
    margin: 18px auto;
    padding: 16px;
  }

  h1 {
    font-size: 1.6rem;
    margin-bottom: 4px;
  }

  p.lead {
    color: var(--muted);
    margin-top: 6px;
  }

  .card {
    background: var(--card);
    border-radius: 12px;
    padding: 18px;
    margin-bottom: 16px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.5);
  }

  label {
    font-size: 0.85rem;
    color: var(--muted);
    margin-bottom: 6px;
    display:block;
  }

  input, select, textarea {
    width: 100%;
    border: 1px solid var(--glass);
    border-radius: 8px;
    background: var(--glass);
    color: var(--neutral);
    padding: 10px;
    font-size: 1rem;
    box-sizing: border-box;
  }

  textarea { min-height: 90px; }

  button {
    background: var(--accent);
    border: none;
    border-radius: 8px;
    padding: 10px 14px;
    color: #032;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover { background: #10b0b0; }
  button.secondary {
    background: transparent;
    border: 1px solid var(--glass);
    color: var(--neutral);
  }

  .notice {
    background: var(--glass);
    padding: 10px;
    border-radius: 8px;
    color: var(--muted);
    font-size: 0.9rem;
    margin-bottom: 14px;
  }

  .flex { display:flex; gap:12px; flex-wrap: wrap; align-items: flex-end; }

  .quiz-area { margin-top: 16px; }
  .q { background: rgba(255,255,255,0.03); border-radius: 8px; padding: 14px; margin-bottom: 12px; }
  .q h3 { font-size: 1rem; margin: 0 0 6px; }

  .option { display:block; margin: 6px 0; }
  .summary { background: rgba(14,165,164,0.07); border-radius: 8px; padding: 10px; margin-top: 10px; }

  .result-correct { color: var(--success); font-weight: 600; }
  .result-wrong { color: var(--danger); font-weight: 600; }
  .explain { font-size: 0.9rem; color: var(--muted); margin-top: 4px; }

  .controls { display:flex; gap:8px; flex-wrap: wrap; margin-top:10px; }
  .tiny { font-size: 0.8rem; color: var(--muted); }

  footer {
    text-align:center;
    color: var(--muted);
    font-size: 0.85rem;
    margin-top: 24px;
  }

  /* ---- Responsividade ---- */
  @media (max-width: 768px) {
    h1 { font-size: 1.4rem; }
    .container { padding: 12px; }
    button, select, input, textarea { font-size: 0.95rem; }
    .flex { flex-direction: column; align-items: stretch; }
    .controls { flex-direction: column; }
    .q h3 { font-size: 0.95rem; }
  }

  @media (max-width: 480px) {
    h1 { font-size: 1.2rem; }
    .q { padding: 10px; }
  }

  .hidden { display:none; }

  .badge {
    display:inline-block;
    padding:4px 8px;
    border-radius:999px;
    background:rgba(255,255,255,0.03);
    font-size:12px;
    margin-left:6px;
  }

  .pill {
    padding:6px 10px;
    border-radius:999px;
    background:rgba(255,255,255,0.02);
    font-size:13px;
  }
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <h1>Gerador de Quiz ‚Äì Revis√£o VA2 (SQL)</h1>
    <p class="lead">Gere quizzes personalizados sobre WHERE/HAVING, JOINs, Views e Subqueries. Escolha a quantidade, cole sua chave da Google AI e pratique.</p>

    <div class="notice">
      ‚ö†Ô∏è <strong>Aviso:</strong> A chave API colada aqui √© usada apenas localmente no navegador para chamadas diretas √† API. N√£o ser√° armazenada. Use somente para estudo/testes.
    </div>

    <div class="flex">
      <div style="flex:1;">
        <label>Google API Key (opcional)</label>
        <input id="apiKey" type="text" placeholder="Cole aqui sua API Key (ex: AIza...)" />
      </div>
      <div style="flex:0 0 180px;">
        <label>N¬∫ de quest√µes</label>
        <select id="qCount">
          <option value="10">10 quest√µes</option>
          <option value="15" selected>15 quest√µes</option>
          <option value="20">20 quest√µes</option>
        </select>
      </div>
    </div>

    <div class="controls" style="margin-top:12px">
      <button id="btnGenerate">Gerar Quiz</button>
      <button id="btnRegenerate" class="secondary" disabled>Gerar Novamente</button>
      <button id="btnClear" class="secondary">Limpar Respostas</button>
      <div style="margin-left:auto" class="tiny">Fonte: Revis√£o VA2 + conte√∫do enviado.</div>
    </div>
  </div>

  <div id="quizWrap" class="card hidden">
    <div style="display:flex;align-items:center;gap:8px">
      <h2 id="quizTitle" style="margin:0">Quiz</h2>
      <div id="meta" class="pill tiny"></div>
      <div style="margin-left:auto" class="tiny">Tempo: <span id="timer">--:--</span></div>
    </div>

    <div class="quiz-area" id="quizArea"></div>

    <div class="controls">
      <button id="btnSubmit">Enviar e Corrigir</button>
      <button id="btnNew" class="secondary">Gerar Novamente (outra varia√ß√£o)</button>
      <div style="margin-left:auto" class="tiny">Dissertativas ser√£o avaliadas pela IA quando poss√≠vel.</div>
    </div>

    <div id="resultArea" class="hidden"></div>
  </div>

  <footer>Feito para estudo ‚Äî Revis√£o VA2 (SQL). Responsivo e pronto para mobile üì±</footer>
</div>

<script>
/*
  quiz.html - vers√£o completa integrando HTML/CSS/JS.
  - Gera quizzes com base no conte√∫do fornecido (Revis√£o VA2).
  - Permite colar Google API Key para avalia√ß√£o autom√°tica de quest√µes dissertativas.
  - Se a chamada √† IA falhar (CORS/erro), faz fallback local mostrando gabarito/crit√©rio.
  - Responsivo e pronto para GitHub Pages.
*/

/* ---------- Conte√∫do (extra√≠do do Revis√£o VA2.docx / texto enviado) ---------- */
const CONTENT = {
  topics: {
    whereHaving: {
      title: "Filtragem (WHERE vs HAVING)",
      bullets: [
        "Use WHERE para filtrar registros individuais (linhas).",
        "Use HAVING para filtrar grupos (resultados de fun√ß√µes de agrega√ß√£o como COUNT, SUM, AVG).",
        "WHERE √© processado ANTES do GROUP BY.",
        "HAVING √© processado DEPOIS do GROUP BY.",
        "N√£o pode usar fun√ß√µes de agrega√ß√£o na cl√°usula WHERE; use HAVING para isso."
      ]
    },
    views: {
      title: "Views (Tabelas Virtuais)",
      bullets: [
        "√â uma tabela virtual, baseada no resultado de um SELECT armazenado.",
        "Vantagens: Seguran√ßa (restringe colunas/linhas) e Simplifica√ß√£o (esconde JOINs e c√°lculos complexos).",
        "Uma View n√£o √© uma c√≥pia f√≠sica dos dados (normalmente).",
        "Comando: CREATE VIEW nome_da_view AS SELECT ...."
      ]
    },
    joins: {
      title: "Jun√ß√µes (JOINs)",
      bullets: [
        "INNER JOIN: retorna apenas registros que existem nas duas tabelas.",
        "LEFT JOIN: retorna todos os registros da tabela da esquerda e preenche com NULL quando n√£o houver correspond√™ncia na direita.",
        "RIGHT JOIN: retorna todos os registros da tabela da direita.",
        "O otimizador do SGBD pode reorganizar JOINs para performance; a ordem escrita afeta legibilidade."
      ]
    },
    subqueries: {
      title: "Subconsultas (Subqueries)",
      bullets: [
        "√â uma consulta SELECT dentro de outra consulta.",
        "Podem ser usadas em SELECT, FROM, WHERE e HAVING.",
        "Usadas com IN para comparar com m√∫ltiplos valores.",
        "N√£o s√£o sempre melhores ou piores que JOINs; depende do caso."
      ]
    }
  },

  // Mini-simulado (base para gerar perguntas e gabarito)
  miniSimulado: [
    // dissertativas (2)
    { type: "essay", id: "d1", text: "Explique a diferen√ßa fundamental de uso e ordem entre as cl√°usulas WHERE e HAVING em uma consulta SQL.", answer: "WHERE filtra linhas individuais e √© executado antes do GROUP BY. HAVING filtra grupos (ap√≥s agrega√ß√£o) e √© executado depois do GROUP BY. HAVING filtra fun√ß√µes (SUM, COUNT), WHERE n√£o." },
    { type: "essay", id: "d2", text: "O que √© uma View e quais s√£o suas duas principais vantagens pr√°ticas?", answer: "Uma View √© uma tabela virtual baseada em um SELECT armazenado. Vantagens: 1) Seguran√ßa (restringir acesso a colunas/linhas) e 2) Simplifica√ß√£o (esconder JOINs e c√°lculos complexos)." },

    // V/F (2)
    { type: "tf", id: "vf1", text: "Um LEFT JOIN da Tabela A (esquerda) para a Tabela B (direita) retornar√° apenas os registros que existem em ambas as tabelas.", answer: false, explanation: "Isso descreve um INNER JOIN. LEFT JOIN retorna todos da esquerda, preenchendo com NULL quando n√£o houver correspond√™ncia." },
    { type: "tf", id: "vf2", text: "A cl√°usula WHERE √© processada antes da cl√°usula GROUP BY, enquanto a cl√°usula HAVING √© processada depois.", answer: true, explanation: "WHERE filtra linhas antes do GROUP BY; HAVING filtra resultados agregados depois do GROUP BY." },

    // Rela√ß√£o (2)
    { type: "relation", id: "r1", text: "I. A cl√°usula HAVING √© necess√°ria para filtrar resultados baseados em fun√ß√µes de agrega√ß√£o como COUNT ou SUM.  II. A cl√°usula WHERE n√£o pode filtrar diretamente resultados de fun√ß√µes agregadas.", correctOption: "D", explanation: "Ambas s√£o verdadeiras; a II justifica a I." },
    { type: "relation", id: "r2", text: "I. Views s√£o usadas para garantir seguran√ßa, permitindo restringir quais colunas e linhas os usu√°rios podem visualizar. II. Elas s√£o tabelas virtuais que armazenam fisicamente uma c√≥pia duplicada dos dados para simplificar os JOINs.", correctOption: "B", explanation: "I √© verdadeira; II √© falsa (Views s√£o virtuais, n√£o c√≥pias f√≠sicas)." },

    // Marque a correta (2)
    { type: "mcq", id: "m1", text: "Em qual das seguintes cl√°usulas N√ÉO √© um local comum para se utilizar uma subconsulta (subquery)?", choices: ["SELECT","FROM","WHERE","ORDER BY"], answerIndex: 3, explanation: "ORDER BY n√£o √© um local padr√£o de uso como as outras tr√™s." },
    { type: "mcq", id: "m2", text: "Qual comando √© usado para criar uma tabela virtual baseada no resultado de uma consulta SELECT armazenada?", choices: ["CREATE TABLE VIRTUAL","CREATE VIEW","CREATE SUBQUERY","SELECT INTO VIEW"], answerIndex: 1, explanation: "CREATE VIEW." },

    // Marque a incorreta (2)
    { type: "wrong", id: "w1", text: "Sobre Subqueries (consultas aninhadas), marque a afirmativa INCORRETA:", choices: ["Podem ser usadas na cl√°usula HAVING.","S√£o √∫teis com o operador IN para comparar com m√∫ltiplos valores retornados pela subquery.","Em termos de performance, subqueries s√£o sempre prefer√≠veis aos JOINs.","Podem ser usadas para calcular um valor (como uma m√©dia) que ser√° usado na consulta principal."], answerIndex: 2, explanation: "Em termos de performance, subqueries n√£o s√£o sempre prefer√≠veis aos JOINs; depende do caso." },
    { type: "wrong", id: "w2", text: "Sobre JOINs, marque a afirmativa INCORRETA:", choices: ["LEFT JOIN retorna todos os registros da tabela da esquerda.","INNER JOIN retorna apenas os registros que t√™m correspond√™ncia em ambas as tabelas.","O otimizador de consultas do SGBD pode reorganizar a execu√ß√£o dos JOINs para melhor performance.","A ordem em que os JOINs s√£o escritos no c√≥digo n√£o afeta em nada a legibilidade da consulta."], answerIndex: 3, explanation: "A ordem escrita afeta legibilidade mesmo que o otimizador mude a execu√ß√£o." }
  ]
};

/* ---------- Helpers ---------- */
function uid(prefix='id'){ return prefix + Math.random().toString(36).slice(2,9); }

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] }
  return arr;
}

/* ---------- Quiz generation logic ---------- */
let currentQuiz = null;

function pickQuestions(count){
  // Start from miniSimulado base and expand with template variations from content
  const base = [...CONTENT.miniSimulado];
  const pool = [];

  // Use base as seeds, but also create small variations programmatically:
  base.forEach(q=>{
    pool.push(JSON.parse(JSON.stringify(q))); // deep copy
    // Create small variations for TF and MCQ by rephrasing slightly
    if(q.type==='tf'){
      const v = JSON.parse(JSON.stringify(q));
      v.id = q.id + '_v2';
      v.text = q.text.replace(/LEFT JOIN/,'LEFT JOIN (vers√£o)');
      pool.push(v);
    }
    if(q.type==='mcq' || q.type==='wrong'){
      const v = JSON.parse(JSON.stringify(q));
      v.id = q.id + '_v2';
      pool.push(v);
    }
  });

  // Also synthesize some new questions from topics for variety:
  const synth = [];
  synth.push({type:'mcq', id:uid('s'), text:'Qual cl√°usula √© processada antes do GROUP BY?', choices:['HAVING','WHERE','ORDER BY','GROUP BY'], answerIndex:1, explanation:'WHERE √© processada antes do GROUP BY.'});
  synth.push({type:'mcq', id:uid('s'), text:'Qual JOIN retorna todos os registros da tabela da esquerda?', choices:['INNER JOIN','LEFT JOIN','RIGHT JOIN','FULL JOIN'], answerIndex:1, explanation:'LEFT JOIN retorna todos da esquerda.'});
  synth.push({type:'tf', id:uid('s'), text:'Uma View √© normalmente uma c√≥pia f√≠sica dos dados.', answer:false, explanation:'Uma View √© virtual, n√£o uma c√≥pia f√≠sica.'});
  synth.push({type:'relation', id:uid('s'), text:'I. WHERE filtra antes do GROUP BY. II. HAVING filtra ap√≥s agrega√ß√£o.', correctOption:'D', explanation:'Ambas verdadeiras e II justifica I.'});
  synth.forEach(s=>pool.push(s));

  // shuffle pool
  shuffle(pool);

  // ensure at least 3 essays
  const essayPool = pool.filter(q=>q.type==='essay');
  if(essayPool.length < 3){
    // duplicate existing essay(s) with slight variations
    const baseEssays = CONTENT.miniSimulado.filter(x=>x.type==='essay');
    let idx = 0;
    while(essayPool.length + (idx) < 3 && idx < baseEssays.length){
      const ex = JSON.parse(JSON.stringify(baseEssays[idx % baseEssays.length]));
      ex.id = ex.id + '_extra_' + idx;
      ex.text = ex.text + ' (varia√ß√£o)';
      pool.push(ex);
      idx++;
    }
  }

  // Now pick exactly `count`, but ensure at least 3 essays
  let selected = [];
  // pick essays first up to 3
  const essays = pool.filter(q=>q.type==='essay');
  for(let i=0; i<Math.min(3, essays.length) && selected.length < count; i++){
    selected.push(essays[i]);
  }

  // fill with non-essay
  const nonEssays = pool.filter(q=>q.type!=='essay');
  let ni = 0;
  while(selected.length < count && ni < nonEssays.length){
    selected.push(nonEssays[ni]); ni++;
  }

  // if still not enough (rare), add remaining pool items
  if(selected.length < count){
    const remaining = pool.filter(q=>!selected.includes(q));
    let ri = 0;
    while(selected.length < count && ri < remaining.length){
      selected.push(remaining[ri]); ri++;
    }
  }

  shuffle(selected);
  return selected.slice(0, count);
}

/* ---------- UI rendering ---------- */
const quizWrap = document.getElementById('quizWrap');
const quizArea = document.getElementById('quizArea');
const meta = document.getElementById('meta');
const timerEl = document.getElementById('timer');
const resultArea = document.getElementById('resultArea');

document.getElementById('btnGenerate').addEventListener('click', ()=>{
  const k = document.getElementById('apiKey').value.trim();
  const count = parseInt(document.getElementById('qCount').value,10);
  generateQuiz(count, k);
});

document.getElementById('btnRegenerate').addEventListener('click', ()=>{
  if(currentQuiz) generateQuiz(currentQuiz.questions.length, currentQuiz.apiKey, true);
});

document.getElementById('btnNew').addEventListener('click', ()=> {
  if(currentQuiz) generateQuiz(currentQuiz.questions.length, currentQuiz.apiKey, true);
});

document.getElementById('btnClear').addEventListener('click', ()=>{
  document.querySelectorAll('#quizArea input[type=radio]').forEach(i=>i.checked=false);
  document.querySelectorAll('#quizArea textarea, #quizArea input[type=text]').forEach(i=>i.value='');
});

document.getElementById('btnSubmit').addEventListener('click', async ()=>{
  if(!currentQuiz) return;
  // collect answers
  const answers = [];
  for(const q of currentQuiz.questions){
    const el = document.getElementById(q._domId);
    if(!el) continue;
    let resp = null;
    if(q.type==='mcq' || q.type==='wrong'){
      const radios = el.querySelectorAll('input[type=radio]');
      for(const r of radios) if(r.checked) resp = parseInt(r.value,10);
    } else if(q.type==='tf'){
      const v = el.querySelector('select');
      resp = v ? (v.value==='true' ? true : (v.value==='false' ? false : null)) : null;
    } else if(q.type==='relation'){
      const s = el.querySelector('select');
      resp = s ? s.value : null;
    } else if(q.type==='essay'){
      const ta = el.querySelector('textarea');
      resp = ta ? ta.value.trim() : '';
    }
    answers.push({id:q.id, type:q.type, question:q, answer:resp});
  }

  // Disable button while grading
  document.getElementById('btnSubmit').disabled = true;
  resultArea.classList.remove('hidden');
  resultArea.innerHTML = '<div class="summary">Corrigindo... Aguarde (pode levar alguns segundos se a IA for chamada)</div>';
  // Grade
  const grading = await gradeAnswers(answers, currentQuiz.apiKey);
  // Show results
  renderResults(grading);
  document.getElementById('btnSubmit').disabled = false;
});

function renderResults(grading){
  const total = grading.length;
  let correct = 0;
  let html = '<h3>Resultado</h3>';
  html += '<div class="summary"><strong>Resumo:</strong> ' + grading.length + ' quest√µes</div>';
  html += '<div style="margin-top:10px">';
  grading.forEach((g, idx)=>{
    const q = g.question;
    html += `<div class="q"><h3>${idx+1}. ${escapeHtml(q.text)}</h3>`;
    if(q.type==='essay'){
      if(g.autoGraded){
        const scoreText = (typeof g.score !== 'undefined' && g.score !== null) ? g.score : '‚Äî';
        html += `<div class="tiny">Nota (auto): <strong>${scoreText}</strong> / 10 <span class="badge">${g.label ?? ''}</span></div>`;
        html += `<div class="explain">${escapeHtml(g.feedback || 'Sem feedback.')}</div>`;
        if(typeof g.score === 'number' && g.score >= 6) correct++;
      } else {
        html += `<div class="tiny">Avalia√ß√£o autom√°tica indispon√≠vel ‚Äî veja a resposta esperada e crit√©rios abaixo.</div>`;
        html += `<div class="explain"><strong>Resposta esperada:</strong> ${escapeHtml(q.answer)}</div>`;
        html += `<div class="explain"><strong>Crit√©rios:</strong> WHERE vs HAVING e ordem de execu√ß√£o; men√ß√£o a fun√ß√µes agregadas. (Marcar 0-10).</div>`;
      }
    } else {
      if(g.correct){
        html += `<div class="result-correct">‚úî Correto</div>`;
        correct++;
      } else {
        html += `<div class="result-wrong">‚úñ Errado</div>`;
        html += `<div class="explain"><strong>Explica√ß√£o:</strong> ${escapeHtml(g.explanation || '‚Äî')}</div>`;
      }
    }
    html += '</div>';
  });
  html += '</div>';
  html += `<div class="summary" style="margin-top:12px"><strong>Acertos:</strong> ${correct} / ${total}</div>`;
  resultArea.innerHTML = html;
}

/* ---------- Grading logic ---------- */
async function gradeAnswers(answers, apiKey){
  // For objective questions, use local gabarito
  const grading = [];
  for(const a of answers){
    const q = a.question;
    const record = {question: q, userAnswer: a.answer, type: a.type, correct:false, explanation:null, autoGraded:false};
    if(a.type==='mcq' || a.type==='wrong'){
      const isCorrect = (a.answer !== null && a.answer === q.answerIndex);
      record.correct = isCorrect;
      record.explanation = q.explanation || '';
      record.autoGraded = true;
    } else if(a.type==='tf'){
      const isCorrect = (typeof a.answer === 'boolean' && a.answer === q.answer);
      record.correct = isCorrect;
      record.explanation = q.explanation || '';
      record.autoGraded = true;
    } else if(a.type==='relation'){
      const isCorrect = (a.answer === q.correctOption);
      record.correct = isCorrect;
      record.explanation = q.explanation || '';
      record.autoGraded = true;
    } else if(a.type==='essay'){
      // Request the AI to grade the essay (scale 0-10) and give feedback (if apiKey provided)
      if(apiKey){
        try{
          const prompt = buildEssayGradingPrompt(q.text, q.answer, a.answer);
          const aiResp = await callGenerativeAPI(apiKey, prompt);
          const parsed = tryParseScoreFeedback(aiResp);
          if(parsed){
            record.autoGraded = true;
            record.score = parsed.score;
            record.feedback = parsed.feedback;
            record.label = parsed.score >= 6 ? 'Bom' : 'Precisa melhorar';
          } else {
            // fallback: place AI raw text as feedback
            record.autoGraded = true;
            record.feedback = aiResp;
            record.score = null;
            record.label = '';
          }
        }catch(err){
          console.warn('AI grading failed',err);
          record.autoGraded = false;
        }
      } else {
        record.autoGraded = false;
      }
    }
    grading.push(record);
  }
  return grading;
}

/* ---------- AI calling utilities ---------- */
async function callGenerativeAPI(apiKey, prompt){
  // Try to call Generative Language API (text-bison style) via REST.
  // We'll attempt to use the "generativelanguage" endpoint as commonly documented.
  // Note: CORS or API changes might break this; we catch errors and return fallback text.
  const endpoint = 'https://generativelanguage.googleapis.com/v1beta2/models/text-bison-001:generateText?key=' + encodeURIComponent(apiKey);
  const body = {
    prompt: { text: prompt },
    temperature: 0.2,
    candidateCount: 1,
    maxOutputTokens: 512
  };

  // Try fetch
  const resp = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if(!resp.ok) {
    const txt = await resp.text();
    throw new Error('API error: ' + resp.status + ' - ' + txt);
  }
  const j = await resp.json();
  // The exact field varies; generative language may return j.candidates[0].output or j.output[0].content[0].text depending on version.
  // Try to extract robustly:
  let textOut = '';
  if(j.candidates && j.candidates[0] && j.candidates[0].output){
    // older format
    textOut = j.candidates[0].output;
  } else if(j.candidates && j.candidates[0] && j.candidates[0].content){
    textOut = j.candidates[0].content.map(c=>c.text || '').join('\n');
  } else if(j.output && j.output[0] && j.output[0].content){
    textOut = j.output[0].content.map(c=>c.text || '').join('\n');
  } else if(j.result && typeof j.result === 'string') {
    textOut = j.result;
  } else {
    textOut = JSON.stringify(j);
  }
  return textOut;
}

function tryParseScoreFeedback(aiText){
  // The prompt we send asks for a JSON with score and feedback. Try to extract numbers.
  // Look for a JSON block
  try{
    const jsonMatch = aiText.match(/\{[\s\S]*\}/);
    if(jsonMatch){
      const obj = JSON.parse(jsonMatch[0]);
      if(typeof obj.score !== 'undefined') return {score: Number(obj.score), feedback: String(obj.feedback || '')};
    }
  }catch(e){}
  // fallback try to find "score: X" patterns
  const scoreMatch = aiText.match(/score[:\s]*([0-9]+(?:\.[0-9]+)?)/i);
  if(scoreMatch){
    const s = Number(scoreMatch[1]);
    const fb = aiText.replace(scoreMatch[0],'').trim();
    return {score: s, feedback: fb};
  }
  return null;
}

function buildEssayGradingPrompt(questionText, expectedAnswer, studentAnswer){
  // Ask the model to grade in JSON format.
  return `Voc√™ √© um avaliador especialista em SQL. Leia a quest√£o e a resposta do aluno. Retorne apenas um JSON v√°lido com formato: {"score": NotaEntre0e10, "feedback": "texto com coment√°rios espec√≠ficos, pontos fortes e pontos a melhorar (curto)"}.

Quest√£o:
${questionText}

Resposta esperada (exemplo / gabarito):
${expectedAnswer}

Resposta do aluno:
${studentAnswer}

Avalie a resposta do aluno comparando com o esperado. Seja objetivo: devolva somente o JSON. Nota de 0 a 10 (n√∫mero). Feedback breve.`;
}

/* ---------- Quiz rendering ---------- */
function generateQuiz(count = 15, apiKey = '', regenerate=false){
  const questions = pickQuestions(count);
  currentQuiz = {questions, apiKey, created: new Date()};
  quizArea.innerHTML = '';
  document.getElementById('btnRegenerate').disabled = false;
  document.getElementById('btnGenerate').disabled = false;
  quizWrap.classList.remove('hidden');
  meta.textContent = `${questions.length} quest√µes ‚Ä¢ gerado em ${currentQuiz.created.toLocaleTimeString()}`;
  resultArea.classList.add('hidden'); resultArea.innerHTML='';

  questions.forEach((q, idx)=>{
    const domId = uid('qdom_'); q._domId = domId;
    const container = document.createElement('div'); container.className = 'q';
    container.id = domId;

    const title = document.createElement('h3'); title.innerHTML = `${idx+1}. ${q.text}`;
    container.appendChild(title);

    const opts = document.createElement('div'); opts.className = 'options';

    if(q.type==='mcq' || q.type==='wrong'){
      const choices = q.choices ? q.choices : (q.choices || []);
      // leave order stable to keep gabarito simple
      choices.forEach((c,i)=>{
        const id = uid('opt_');
        const label = document.createElement('label');
        label.className = 'option';
        label.innerHTML = `<input type="radio" name="${domId}_mcq" value="${i}"> ${escapeHtml(c)}`;
        opts.appendChild(label);
      });
    } else if(q.type==='tf'){
      opts.innerHTML = `<label class="option"><select><option value="">-- escolha --</option><option value="true">Verdadeiro</option><option value="false">Falso</option></select></label>`;
    } else if(q.type==='relation'){
      opts.innerHTML = `<label class="option small">Marque a alternativa correta: <select><option value="">-- escolha --</option><option value="A">A</option><option value="B">B</option><option value="C">C</option><option value="D">D</option></select></label>`;
    } else if(q.type==='essay'){
      opts.innerHTML = `<label class="option"><textarea class="answer" placeholder="Escreva sua resposta aqui..."></textarea></label>`;
    } else { opts.innerHTML = `<div class="tiny">Tipo de quest√£o n√£o suportado.</div>`; }

    container.appendChild(opts);
    quizArea.appendChild(container);
  });

  // start a basic timer (optional)
  startTimer(20*60); // 20 minutes visual timer
}

/* ---------- Timer ---------- */
let timerInterval = null;
function startTimer(seconds){
  if(timerInterval) clearInterval(timerInterval);
  let s = seconds;
  function update(){
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    timerEl.textContent = `${mm}:${ss}`;
    if(s>0) s--; else clearInterval(timerInterval);
  }
  update();
  timerInterval = setInterval(update,1000);
}

/* ---------- Utilities ---------- */
function escapeHtml(s){
  if(!s) return '';
  return String(s).replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]; });
}

/* ---------- On load: initialize minimal state ---------- */
(function init(){
  // no pre-generation, wait user action
})();

</script>
</body>
</html>
