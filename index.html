<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gerador de Quiz — POO & WEB (Revisão)</title>
  
  <style>
    /* Conteúdo do style.css colado aqui */
    :root{
      --bg1:#071225; --bg2:#07192a; --card:#0b1320; --muted:#94a3b8; --accent:#0ea5a4;
      --success:#16a34a; --danger:#ef4444; --glass:rgba(255,255,255,0.03); --text:#e6eef6;
      --shadow: 0 8px 30px rgba(2,6,23,0.6);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:
      radial-gradient(ellipse at top left, rgba(14,165,164,0.06), transparent 20%),
      linear-gradient(180deg,var(--bg1),var(--bg2));
      color:var(--text); 
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .hidden {
      display: none;
    }

    .wrap{max-width:980px;margin:22px auto;padding:16px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px;padding:16px;margin-bottom:14px;box-shadow:var(--shadow)}
    .header{display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
    .header h1{margin:0;font-size:1.4rem}
    .lead{color:var(--muted);margin:6px 0 0;font-size:0.95rem}
    .pill{background:rgba(255,255,255,0.02);padding:6px 10px;border-radius:999px;font-size:0.9rem}

    .form-grid{display:grid;grid-template-columns:1fr 220px 160px 220px;gap:12px;align-items:end}
    .form-grid label{font-size:0.85rem;color:var(--muted);margin-bottom:6px;display:block}

    input,select,textarea{
      width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);
      background:var(--glass);color:var(--text);
      outline: 2px solid transparent; 
      outline-offset: 2px;
      transition: outline-color 0.2s;
    }
    input:focus-visible, 
    select:focus-visible, 
    textarea:focus-visible {
      outline-color: var(--accent);
    }

    .tiny{font-size:0.82rem;color:var(--muted)}
    .actions{display:flex;gap:8px}

    button{background:var(--accent);color:#032;border:none;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer; transition: filter 0.2s, transform 0.1s;}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--text)}

    button:hover {
      filter: brightness(1.15);
    }
    button:active {
      filter: brightness(0.9);
      transform: translateY(1px);
    }
    button:disabled {
      background: var(--glass);
      color: var(--muted);
      cursor: not-allowed;
      filter: none;
      transform: none;
    }
    button.secondary:disabled {
        background: transparent;
        border-color: var(--glass);
    }

    .notice{margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted)}

    .quiz-header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .quiz-area{margin-top:12px}

    .quiz-area + .controls {
      margin-top: 12px;
    }

    .q{padding:12px;border-radius:8px;background:rgba(255,255,255,0.01);margin-bottom:12px}
    .q h3{margin:0;font-size:1rem; margin-bottom: 10px;}
    .options{margin-top:8px}
    
    /* --- INÍCIO DA CORREÇÃO DE RESPONSIVIDADE --- */
    .option{
      display:flex; /* Muda para flexbox */
      gap:8px; /* Espaço entre o radio/check e o texto */
      align-items:flex-start; /* Alinha no topo */
      margin: 10px 0;
    }
    .option input[type="radio"] {
      flex-shrink: 0; /* Impede o radio button de encolher */
      margin-top: 3px; /* Ajuste fino de alinhamento vertical */
    }
    
    .multi-relation { display:flex; flex-direction:column; gap:6px; margin-top:8px; }
    .multi-relation label {
      display:flex; /* Muda para flexbox */
      gap:8px; /* Espaço */
      align-items:flex-start; /* Alinha no topo */
    }
    .multi-relation label input[type="checkbox"] {
      flex-shrink: 0; /* Impede o checkbox de encolher */
      margin-top: 3px; /* Ajuste fino */
    }
    .multi-relation label strong {
      flex-shrink: 0; /* Impede o "I." de encolher */
    }
    /* O <span> que será adicionado via JS vai quebrar a linha naturalmente */
    /* --- FIM DA CORREÇÃO DE RESPONSIVIDADE --- */

    textarea.answer{min-height:96px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:var(--text)}
    .result-area{margin-top:12px}
    .summary{padding:10px;border-radius:8px;background:linear-gradient(90deg, rgba(14,165,164,0.05), transparent)}
    .result-correct{color:var(--success);font-weight:700}
    .result-wrong{color:var(--danger);font-weight:700}
    .explain{margin-top:8px;color:var(--muted);font-size:0.93rem}
    .footer{text-align:center;color:var(--muted);font-size:0.9rem;margin-top:8px}


    @media (max-width: 900px){
      .form-grid{grid-template-columns:1fr 180px 140px; }
      .header{flex-direction:column; align-items:flex-start}
    }
    @media (max-width: 640px){
      .form-grid{grid-template-columns:1fr; }
      .actions{flex-direction:column}
      .header h1{font-size:1.15rem}
      .pill{font-size:0.85rem}
      
      /* Correção de responsividade bônus */
      .quiz-header { flex-wrap: wrap; gap: 6px; }
    }
  </style>
</head>
<body>
  
  <div class="wrap">
    <header class="header card">
      <div>
        <h1>Gerador de Quiz — Revisão POO &amp; WEB</h1>
        <p class="lead">Escolha a matéria, cole sua API Key do Google (opcional), selecione o número de questões e pratique.</p>
      </div>
      <div class="meta">
        <div class="pill">Responsivo • Pronto para estudo</div>
      </div>
    </header>

    <main>
      <section class="card controls">
        <div class="form-grid">
          <div>
            <label for="apiKey">Google API Key (opcional)</label>
            <input id="apiKey" type="text" placeholder="Cole sua chave aqui (ex: AIza...)">
            <small class="tiny">Usada apenas localmente no navegador para avaliar respostas dissertativas.</small>
          </div>

          <div>
            <label for="subject">Matéria</label>
            <select id="subject">
              <option value="POO" selected>POO (SOLID, Arquitetura, MVC)</option>
              <option value="WEB">WEB (HTTP, JSON, Node.js, APIs)</option>
            </select>
          </div>

          <div>
            <label for="qCount">Número de questões</label>
            <select id="qCount">
              <option value="10">10 questões</option>
              <option value="15" selected>15 questões</option>
              <option value="20">20 questões</option>
            </select>
          </div>

          <div class="actions">
            <button id="btnGenerate" type="button">Gerar Quiz</button>
            <button id="btnRegenerate" type="button" class="secondary" disabled>Gerar Novamente</button>
            <button id="btnClear" type="button" class="secondary">Limpar Respostas</button>
          </div>
        </div>

        <div class="notice">
          <strong>Atenção:</strong> Colar sua API Key no navegador expõe a chave localmente — use apenas para estudo pessoal. Em produção, mova chamadas para um backend.
        </div>
      </section>

      <section id="quizSection" class="card hidden">
        <div class="quiz-header">
          <h2 id="quizTitle">Quiz</h2>
          <div class="quiz-meta">
            <span id="meta" class="pill tiny"></span>
          </div>
          <div style="margin-left: auto;">
             <span class="tiny">Tempo (visual): <strong id="timer">--:--</strong></span>
          </div>
        </div>

        <div id="quizArea" class="quiz-area"></div>

        <div class="controls actions"> 
          <button id="btnSubmit" type="button">Enviar e Corrigir</button>
          <button id="btnNew" type="button" class="secondary">Gerar Novamente (outra variação)</button>
        </div>

        <div id="resultArea" class="result-area hidden"></div>
      </section>
    </main>

    <footer class="footer">
      <small>Feito para estudo — use com responsabilidade. Conteúdos: POO e WEB (baseados no seu material).</small>
    </footer>
  </div>

  <script>
    /* Conteúdo do script.js colado aqui */

    /* ---------- Conteúdo (POO) ---------- */
    const POO_CONTENT = {
      miniSimulado: [
        { 
          type: "essay", 
          id: "p_essay1", 
          text: "Uma classe RelatorioService possui um método que, baseado em um parâmetro, usa uma série de if/else para decidir se o relatório deve ser gerado em PDF, Excel ou CSV. Explique qual princípio SOLID isso viola e por quê.", 
          answer: "Viola o Princípio Aberto/Fechado (OCP). Porque para adicionar um novo formato de relatório (ex: HTML), o desenvolvedor é obrigado a modificar a classe RelatorioService adicionando um novo else if." 
        },
        { 
          type: "essay", 
          id: "p_essay2", 
          text: "Descreva brevemente o que é a arquitetura de Microsserviços e por que ela seria uma boa escolha para um sistema financeiro que precisa escalar apenas o módulo de processamento de transações.", 
          answer: "É uma arquitetura que divide o sistema em serviços menores e independentes. Ela é uma boa escolha nesse cenário pois permite escalabilidade granular: em vez de escalar o sistema inteiro (como no monolito), a empresa pode escalar apenas o microsserviço de processamento de transações, que é o que recebe a alta demanda." 
        },
        { 
          type: "tf", 
          id: "p_vf1", 
          text: "O Princípio da Inversão de Dependência (DIP) afirma que módulos de alto nível, como FaturaService, devem depender diretamente de módulos de baixo nível, como EmailSender.",
          answer: false, 
          explanation: "Falso (O DIP afirma o exato oposto: módulos de alto nível devem depender de abstrações/interfaces, e não de classes concretas de baixo nível)." 
        },
        { 
          type: "tf", 
          id: "p_vf2", 
          text: "Na arquitetura Serverless, os servidores não existem mais, e o código é executado sem nenhuma infraestrutura física.", 
          answer: false, 
          explanation: "Falso (Os servidores ainda existem, mas eles são gerenciados pelo provedor de nuvem, não por você)." 
        },
        { 
          type: "relation", 
          id: "p_rel1", 
          text: "I. Uma classe PedidoService que calcula o total do pedido e também registra logs detalhados em um arquivo de texto viola o Princípio da Responsabilidade Única (SRP). PORQUE II. Essa classe possui mais de um motivo para ser alterada: uma mudança na regra de cálculo de total ou uma mudança no formato do log.", 
          correctOption: "D", 
          explanation: "As duas são verdadeiras, e a II justifica a I (A classe viola o SRP exatamente porque tem dois motivos para mudar: as regras de negócio e as regras de log )." 
        },
        { 
          type: "relation", 
          id: "p_rel2", 
          text: "I. Uma interface Notificador que obriga todas as classes a implementar enviarEmail(), enviarSMS() e enviarPush(), mesmo que elas não usem todos, viola o Princípio da Segregação de Interfaces (ISP). PORQUE II. O Princípio da Responsabilidade Única (SRP) afirma que interfaces não devem ser 'gordas'.", 
          correctOption: "B", 
          explanation: "A asserção I é verdadeira, e a II é falsa (A I está correta, é uma violação do ISP. A II está errada; a descrição 'interfaces não devem ser gordas' é do ISP, não do SRP )." 
        },
        { 
          type: "mcq", 
          id: "p_mcq1", 
          text: "Em um sistema de pagamentos, a classe base Pagamento tem o método processar(). A subclasse PagamentoBoleto implementa processar() lançando uma exceção 'Operação não suportada'. Qual princípio SOLID foi violado?", 
          choices: ["Princípio Aberto/Fechado (OCP)", "Princípio da Substituição de Liskov (LSP)", "Princípio da Inversão de Dependência (DIP)", "Princípio da Segregação de Interfaces (ISP)"], 
          answerIndex: 1, 
          explanation: "A resposta correta é B: Princípio da Substituição de Liskov (LSP). A subclasse não se comporta como a classe mãe, quebrando o contrato e tornando-a não substituível." 
        },
        { 
          type: "mcq", 
          id: "p_mcq2", 
          text: "No padrão MVC, qual camada é responsável por conter os dados e as regras de negócio do sistema?", 
          choices: ["View", "Controller", "Model", "Service"], 
          answerIndex: 2, 
          explanation: "A resposta correta é C: O Model contém os dados e as regras de negócio." 
        },
        { 
          type: "wrong", 
          id: "p_w1", 
          text: "Sobre Arquitetura de Microsserviços, marque a afirmativa INCORRETA:", 
          choices: ["Ajuda a escalar partes específicas de um sistema financeiro, como o processamento de transações.", "É um sistema dividido em serviços menores e independentes.", "Um desafio comum é a complexidade na comunicação entre os serviços.", "É considerada uma arquitetura mais simples de implantar e gerenciar do que um Monolito."], 
          answerIndex: 3, 
          explanation: "A afirmativa D é incorreta. Microsserviços são mais complexos de implantar e gerenciar do que um Monolito, embora o Monolito seja mais simples *inicialmente*." 
        },
        { 
          type: "wrong", 
          id: "p_w2", 
          text: "Sobre o Princípio da Inversão de Dependência (DIP), marque a afirmativa INCORRETA:", 
          choices: ["Módulos de alto nível devem depender de abstrações (interfaces).", "Módulos de baixo nível (classes concretas) devem implementar as abstrações.", "NotificationManager instanciando new SmsService() é uma violação do DIP.", "O principal benefício do DIP é garantir que a classe filha possa substituir a classe mãe sem quebrar o sistema."], 
          answerIndex: 3, 
          explanation: "A afirmativa D é incorreta. O benefício descrito (filha substituir a mãe) é do Princípio da Substituição de Liskov (LSP), não do DIP." 
        },
        { 
          type: "multiRelation", 
          id: "p_mult1", 
          text: "Considere as afirmações sobre interfaces (ISP):\nI. Uma interface Notificador com enviarEmail(), enviarSMS() e enviarPush() força implementações a métodos que podem não usar.\nII. Isso viola o ISP.\nIII. Segregar em interfaces menores (INotificadorEmail, INotificadorSMS) é recomendado.\nIV. SRP é aplicável a interfaces e diz que interfaces não devem ter mais de um método.\nV. Uma interface 'gorda' melhora a reutilização em todos os casos.", 
          answers: ["I","II","III"], 
          explanation: "I, II e III são verdadeiras; IV (ISP fala sobre interfaces 'gordas', não SRP) e V são falsas." 
        }
      ]
    };

    /* ---------- Conteúdo (WEB) ---------- */
    const WEB_CONTENT = {
      miniSimulado: [
        { 
          type: "essay", 
          id: "w_essay1", 
          text: "Explique o que é uma API e como ela facilita a integração entre dois sistemas, como um aplicativo de celular e um servidor web.", 
          answer: "Uma API é um conjunto de regras que permite a comunicação entre sistemas. Ela facilita a integração permitindo que o aplicativo de celular (cliente) envie requisições (ex: GET /produtos) para o servidor. O servidor processa o pedido, busca no banco de dados e retorna os dados em JSON, que o aplicativo entende e exibe ao usuário." 
        },
        { 
          type: "essay", 
          id: "w_essay2", 
          text: "Descreva como ocorre a comunicação entre o frontend e o backend no processo de um usuário realizando um login.", 
          answer: "O usuário preenche o formulário (frontend), o JavaScript envia uma requisição POST para /login contendo o JSON com email e senha. O backend (servidor) recebe, busca o usuário, compara a senha enviada com a senha criptografada no banco. Se bater, ele retorna uma resposta de sucesso (ex: um token); se não, retorna um erro de autenticação." 
        },
        { 
          type: "tf", 
          id: "w_vf1", 
          text: "O Node.js é um ambiente de execução que permite ao JavaScript do frontend (navegador) acessar diretamente o banco de dados do servidor para maior performance.", 
          answer: false, 
          explanation: "Node.js permite ao servidor acessar o banco de dados, não ao frontend." 
        },
        { 
          type: "tf", 
          id: "w_vf2", 
          text: "Para converter uma string de texto no formato JSON para um objeto JavaScript utilizável, deve-se usar o método JSON.stringify().", 
          answer: false, 
          explanation: "Para converter JSON (string) para Objeto JS, usa-se JSON.parse(). JSON.stringify() faz o oposto." 
        },
        { 
          type: "relation", 
          id: "w_rel1", 
          text: "I. O verbo HTTP POST é usado para criar um novo recurso, enquanto o verbo PUT é usado para atualizar/substituir um recurso existente. PORQUE II. A principal diferença entre eles é que o PUT é idempotente (várias chamadas têm o mesmo resultado), enquanto o POST não é (várias chamadas criam vários recursos).", 
          correctOption: "D", 
          explanation: "As duas são verdadeiras, e a II justifica a I (A I define os verbos. A II explica a razão da diferença técnica (idempotência), o que justifica a separação de uso entre criar e atualizar )." 
        },
        { 
          type: "relation", 
          id: "w_rel2", 
          text: "I. O JSON é considerado o formato de dados mais compatível com o JavaScript. PORQUE II. A estrutura de um objeto JSON é idêntica à de um objeto JavaScript, não necessitando de nenhuma conversão para ser utilizado no código.", 
          correctOption: "B", 
          explanation: "A asserção I é verdadeira, e a II é falsa (A I é verdadeira, a sintaxe é muito compatível. A II é falsa; JSON é uma string e precisa de conversão (JSON.parse()) para virar um objeto JS. Além disso, chaves JSON precisam de aspas duplas, diferente de objetos JS)." 
        },
        { 
          type: "mcq", 
          id: "w_mcq1", 
          text: "Qual é a principal função do backend em uma aplicação web?", 
          choices: ["Tornar a página interativa com animações e validação de formulários.", "Armazenar os dados de login e senha no localStorage do navegador.", "Executar a lógica de negócio, acessar o banco de dados e gerenciar a autenticação.", "Renderizar o HTML e o CSS que o usuário vê na tela."], 
          answerIndex: 2, 
          explanation: "A resposta correta é C: O backend executa a lógica de negócio, acessa o banco de dados e gerencia a autenticação." 
        },
        { 
          type: "mcq", 
          id: "w_mcq2", 
          text: "Qual é a forma correta de lidar com um erro que pode ocorrer em uma função async no Node.js?", 
          choices: ["Usando if (error) após a chamada da função.", "Usando o método .catch() no final da chamada await.", "Envolvendo a chamada await (que pode falhar) dentro de um bloco try...catch.", "O await já trata os erros automaticamente, não sendo necessário nenhum bloco extra."], 
          answerIndex: 2, 
          explanation: "A resposta correta é C: A forma padrão de tratar erros com async/await é usando try...catch." 
        },
        { 
          type: "wrong", 
          id: "w_w1", 
          text: "Sobre os verbos HTTP e APIs RESTful, marque a afirmativa INCORRETA:", 
          choices: ["GET é usado para buscar dados de um recurso.", "DELETE é usado para remover um recurso.", "POST é usado para atualizar completamente um recurso que já existe.", "Uma boa prática de API RESTful é usar substantivos nos endpoints, como /usuarios."], 
          answerIndex: 2, 
          explanation: "A afirmativa C é incorreta. POST é usado para criar um novo recurso; PUT (ou PATCH) é usado para atualizar." 
        },
        { 
          type: "wrong", 
          id: "w_w2", 
          text: "Sobre o processo de autenticação no backend, marque a afirmativa INCORRETA:", 
          choices: ["O backend recebe os dados de login (email e senha) do frontend.", "O backend deve usar criptografia ao armazenar e verificar senhas.", "Uma boa prática é armazenar a senha do usuário em texto puro no banco de dados para facilitar a verificação.", "O servidor retorna uma resposta de sucesso (geralmente com um token) ou uma resposta de erro."], 
          answerIndex: 2, 
          explanation: "A afirmativa C é incorreta. Armazenar senhas em texto puro é uma falha grave de segurança." 
        },
        { 
          type: "multiRelation", 
          id: "w_mult1", 
          text: "Considere as afirmações sobre JSON e JS:\nI. JSON é uma string textual.\nII. JSON.parse() converte string JSON em objeto JS.\nIII. JSON.stringify() converte objeto JS para string JSON.\nIV. Em JSON, as chaves não precisam estar entre aspas.\nV. JSON e objeto JS são o mesmo sem conversão.", 
          answers: ["I","II","III"], 
          explanation: "I, II e III verdadeiras; IV (chaves JSON *precisam* de aspas) e V são falsas." 
        }
      ]
    };

    /* ---------- Helpers ---------- */
    function uid(prefix='id'){ return prefix + Math.random().toString(36).slice(2,9); }
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }
    function escapeHtml(s){ if(!s) return ''; return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
    function arraysEqualIgnoreOrder(a,b){ if(!Array.isArray(a) || !Array.isArray(b)) return false; if(a.length !== b.length) return false; const aa = a.slice().map(x=>String(x).trim().toUpperCase()).sort(); const bb = b.slice().map(x=>String(x).trim().toUpperCase()).sort(); for(let i=0;i<aa.length;i++) if(aa[i] !== bb[i]) return false; return true; }

    /* ---------- DOM refs ---------- */
    const apiKeyInput = document.getElementById('apiKey');
    const subjectSelect = document.getElementById('subject');
    const qCountSelect = document.getElementById('qCount');
    const btnGenerate = document.getElementById('btnGenerate');
    const btnRegenerate = document.getElementById('btnRegenerate');
    const btnClear = document.getElementById('btnClear');
    const btnNew = document.getElementById('btnNew');
    const quizSection = document.getElementById('quizSection');
    const quizArea = document.getElementById('quizArea');
    const metaEl = document.getElementById('meta');
    const timerEl = document.getElementById('timer');
    const resultArea = document.getElementById('resultArea');
    const btnSubmit = document.getElementById('btnSubmit');

    let currentQuiz = null;
    let timerInterval = null;

    /* ---------- Events ---------- */
    btnGenerate.addEventListener('click', ()=> {
      const key = apiKeyInput.value.trim();
      const subj = subjectSelect.value;
      const count = parseInt(qCountSelect.value,10);
      generateQuiz(count, subj, key);
    });
    btnRegenerate.addEventListener('click', ()=> { if(currentQuiz) generateQuiz(currentQuiz.questions.length, currentQuiz.subject, currentQuiz.apiKey, true); });
    btnNew.addEventListener('click', ()=> { if(currentQuiz) generateQuiz(currentQuiz.questions.length, currentQuiz.subject, currentQuiz.apiKey, true); });
    btnClear.addEventListener('click', ()=> {
      document.querySelectorAll('#quizArea input[type=radio]').forEach(i=>i.checked=false);
      document.querySelectorAll('#quizArea textarea, #quizArea input[type=text]').forEach(i=>i.value='');
      document.querySelectorAll('#quizArea select').forEach(s=>s.selectedIndex=0);
      document.querySelectorAll('#quizArea input[type=checkbox]').forEach(c=>c.checked=false);
    });
    btnSubmit.addEventListener('click', async ()=> {
      if(!currentQuiz) return;
      btnSubmit.disabled = true;
      resultArea.classList.remove('hidden');
      resultArea.innerHTML = `<div class="summary">Corrigindo... (pode levar alguns segundos se a IA for chamada)</div>`;
      try{
        const results = await gradeAnswers(currentQuiz.apiKey || apiKeyInput.value.trim());
        renderResults(results);
      }catch(err){
        resultArea.innerHTML = `<div class="summary">Erro ao corrigir: ${escapeHtml(String(err.message || err))}</div>`;
        console.error(err);
      } finally {
        btnSubmit.disabled = false;
      }
    });

    
    /* ---------- Question selection (CORRIGIDA E OTIMIZADA) ---------- */
    function pickQuestions(count, subject){
      const poolBase = (subject === 'POO') ? POO_CONTENT.miniSimulado.slice() : WEB_CONTENT.miniSimulado.slice();
      const pool = poolBase.map(q => JSON.parse(JSON.stringify(q)));
      
      let essays = pool.filter(q=>q.type==='essay');
      if(essays.length < 3){
        const base = pool.filter(q=>q.type==='essay');
        let i=0;
        while(essays.length < 3 && i < 5){
          if(base.length === 0) break;
          const ex = JSON.parse(JSON.stringify(base[i % base.length]));
          ex.id = ex.id + '_dup' + i;
          ex.text = ex.text + ' (variação)';
          pool.push(ex);
          essays = pool.filter(q=>q.type==='essay');
          i++;
        }
      }
      
      shuffle(pool);
      
      const selected = [];
      
      const essayList = pool.filter(q=>q.type==='essay');
      for(let i=0;i<Math.min(3, essayList.length) && selected.length < count;i++) {
          selected.push(essayList[i]);
      }
      
      const rest = pool.filter(q=>!selected.includes(q));
      let ri = 0;
      while(selected.length < count && ri < rest.length){ 
          selected.push(rest[ri]); 
          ri++; 
      }
      
      // OTIMIZAÇÃO: Se 'count' for maior que a piscina, preenche com duplicatas
      if(selected.length < count){
        console.warn(`Piscina (${selected.length}) menor que o solicitado (${count}). Adicionando duplicatas.`);
        const needed = count - selected.length;
        
        for(let j=0; j < needed; j++) {
            const randQ = poolBase[Math.floor(Math.random() * poolBase.length)];
            const newDup = JSON.parse(JSON.stringify(randQ));
            newDup.id = newDup.id + '_dup_fill_' + j;
            selected.push(newDup);
        }
      }
      
      shuffle(selected);
      return selected.slice(0,count);
    }

    /* ---------- Render quiz (CORRIGIDO PARA RESPONSIVIDADE) ---------- */
    function generateQuiz(count=15, subject='POO', apiKey='', regenerate=false){
      const questions = pickQuestions(count, subject);
      currentQuiz = { questions, subject, apiKey, created: new Date() };
      quizArea.innerHTML = '';
      quizSection.classList.remove('hidden');
      metaEl.textContent = `${questions.length} questões • ${subject} • gerado em ${currentQuiz.created.toLocaleTimeString()}`;
      resultArea.classList.add('hidden'); resultArea.innerHTML = '';
      btnRegenerate.disabled = false;

      questions.forEach((q, idx) => {
        const domId = uid('q_'); q._domId = domId;
        const card = document.createElement('div'); card.className = 'q'; card.id = domId;
        const title = document.createElement('h3'); 
        
        if (q.type !== 'multiRelation') {
            title.innerHTML = `${idx+1}. ${q.text}`;
        }
        card.appendChild(title);

        const opts = document.createElement('div'); opts.className = 'options';

        if(q.type === 'mcq' || q.type === 'wrong'){
          q.choices = q.choices || [];
          if(typeof q.answerIndex === 'undefined') q.answerIndex = 0;
          const indexed = q.choices.map((c,i)=>({text:c, orig:i}));
          shuffle(indexed);
          q._shuffled = indexed.map(it=>it.orig); 
          indexed.forEach((it,j)=>{
            const label = document.createElement('label'); label.className='option';
            // Adicionado <span> para quebra de linha
            label.innerHTML = `<input type="radio" name="${domId}_opt" value="${j}"> <span>${escapeHtml(it.text)}</span>`;
            opts.appendChild(label);
          });
        } else if(q.type === 'tf'){
          const sel = document.createElement('select'); sel.className='option';
          sel.innerHTML = `<option value="">-- escolha --</option><option value="true">Verdadeiro</option><option value="false">Falso</option>`;
          opts.appendChild(sel);
          
        } else if(q.type === 'relation'){
          const relationOptions = [
            { value: "A", text: "A asserção I é falsa, e a II é verdadeira." },
            { value: "B", text: "A asserção I é verdadeira, e a II é falsa." },
            { value: "C", text: "As duas são verdadeiras, mas a II não justifica a I." },
            { value: "D", text: "As duas são verdadeiras, e a II justifica a I." }
          ];
          relationOptions.forEach(opt => {
            const label = document.createElement('label'); 
            label.className = 'option';
            // Adicionado <span> para quebra de linha
            label.innerHTML = `<input type="radio" name="${domId}_opt" value="${opt.value}"> <span>${escapeHtml(opt.text)}</span>`;
            opts.appendChild(label);
          });
          
        } else if(q.type === 'multiRelation'){
          const wrap = document.createElement('div'); wrap.className='multi-relation';
          const lines = q.text.split('\n').map(s=>s.trim()).filter(Boolean);
          let statements = [];
          let prompt = q.text; 

          if (q.statements && Array.isArray(q.statements)) {
            statements = q.statements.slice();
            prompt = lines[0] || q.text; 
          } else if (lines.length > 1) {
            prompt = lines[0]; 
            statements = lines.slice(1);
          } else {
            statements = q.statements ? q.statements.slice() : ['I. (afirmação 1)','II. (afirmação 2)','III. (afirmação 3)','IV. (afirmação 4)','V. (afirmação 5)'];
          }
          
          title.innerHTML = `${idx+1}. ${prompt}`;
          
          const romans = ['I','II','III','IV','V'];
          for(let i=0;i<statements.length;i++){
            const stmt = statements[i].replace(/^I+\.?\s*/i,'').replace(/^[IVX]+\.\s*/i,'').trim();
            const label = document.createElement('label');
            const idcb = uid('cb_');
            // Adicionado <span> para quebra de linha
            label.innerHTML = `<input type="checkbox" id="${idcb}" data-label="${romans[i]}"> <strong>${romans[i]}.</strong> <span>${escapeHtml(stmt)}</span>`;
            wrap.appendChild(label);
          }
          if(!Array.isArray(q.answers)) q.answers = q.answers || [];
          opts.appendChild(wrap);
          
        } else if(q.type === 'essay'){
          const ta = document.createElement('textarea'); ta.className='answer'; ta.placeholder = 'Escreva sua resposta aqui...';
          opts.appendChild(ta);
        } else { opts.appendChild(document.createTextNode('Tipo não suportado.')); }

        card.appendChild(opts);
        quizArea.appendChild(card);
      });

      startTimer(20*60);
    }

    /* ---------- Grade answers ---------- */
    async function gradeAnswers(apiKey){
      if(!currentQuiz) return [];
      const results = [];
      for(const q of currentQuiz.questions){
        const el = document.getElementById(q._domId);
        const res = { question: q, type: q.type, userAnswer: null, correct:false, explanation:'', autoGraded:false };
        
        if(q.type === 'mcq' || q.type === 'wrong'){
          const checked = el.querySelector('input[type=radio]:checked');
          if(checked){
            const selIndex = parseInt(checked.value,10); 
            const origIndex = (q._shuffled && q._shuffled[selIndex] !== undefined) ? q._shuffled[selIndex] : selIndex;
            res.userAnswer = origIndex;
            res.correct = (origIndex === q.answerIndex);
          } else {
            res.userAnswer = null; res.correct = false;
          }
          res.explanation = q.explanation || '';
          res.autoGraded = true;
          
        } else if(q.type === 'tf'){
          const sel = el.querySelector('select');
          res.userAnswer = (sel && sel.value !== '') ? (sel.value === 'true') : null;
          res.correct = (typeof res.userAnswer === 'boolean' && res.userAnswer === q.answer);
          res.explanation = q.explanation || '';
          res.autoGraded = true;
          
        } else if(q.type === 'relation'){
          const checked = el.querySelector('input[type=radio]:checked');
          if(checked){
            res.userAnswer = checked.value;
            res.correct = (res.userAnswer === q.correctOption);
          } else {
            res.userAnswer = null; res.correct = false;
          }
          res.explanation = q.explanation || '';
          res.autoGraded = true;
          
        } else if(q.type === 'multiRelation'){
          const checked = Array.from(el.querySelectorAll('input[type=checkbox]:checked')).map(c=>c.dataset.label).filter(Boolean);
          res.userAnswer = checked;
          const expected = (q.answers || []).map(x=>String(x).trim().toUpperCase());
          res.correct = arraysEqualIgnoreOrder(expected, checked || []);
          res.explanation = q.explanation || '';
          res.autoGraded = true;
          
        } else if(q.type === 'essay'){
          const ta = el.querySelector('textarea');
          res.userAnswer = ta ? ta.value.trim() : '';
          if(apiKey && res.userAnswer){
            try{
              const prompt = buildEssayGradingPrompt(q.text, q.answer || '', res.userAnswer);
              const aiResp = await callGenerativeAPI(apiKey, prompt);
              const parsed = tryParseScoreFeedback(aiResp);
              if(parsed){
                res.autoGraded = true;
                res.score = parsed.score;
                res.feedback = parsed.feedback;
                res.label = parsed.score >= 6 ? 'Bom' : 'Precisa melhorar';
                res.correct = parsed.score >= 6;
              } else {
                res.autoGraded = true;
                res.feedback = aiResp; 
                res.correct = false;
              }
            }catch(err){
              console.warn('AI grading failed', err);
              res.autoGraded = false;
              res.feedback = `Erro ao contatar IA: ${err.message}`;
            }
          } else {
            res.autoGraded = false;
            res.feedback = 'Correção automática não disponível (sem chave de API ou sem resposta).';
          }
        } else {
          res.autoGraded = false;
        }
        results.push(res);
      }
      return results;
    }

    /* ---------- Render results ---------- */
    function renderResults(results){
      resultArea.classList.remove('hidden');
      let html = `<h3>Resultado</h3>`;
      let correctCount = 0;
      
      results.forEach(r => {
          if (r.type === 'essay') {
              if (r.autoGraded && typeof r.score === 'number' && r.score >= 6) {
                  correctCount++;
              }
          } else if (r.correct) {
              correctCount++;
          }
      });

      html += `<div class="summary"><strong>Total de Acertos:</strong> ${correctCount} / ${results.length} questões</div>`;
      html += `<div style="margin-top:10px">`;
      
      results.forEach((r, idx) => {
        html += `<div class="q"><h3>${idx+1}. ${escapeHtml(r.question.text)}</h3>`; 
        
        if(r.type === 'essay'){
          if(r.autoGraded){
            const score = (typeof r.score === 'number') ? r.score : '—';
            const statusClass = (typeof r.score === 'number' && r.score >= 6) ? 'result-correct' : 'result-wrong';
            html += `<div class="tiny ${statusClass}">Nota (auto): <strong>${score}</strong> / 10 <span class="pill">${r.label || ''}</span></div>`;
            html += `<div class="explain"><strong>Feedback:</strong> ${escapeHtml(r.feedback || 'Sem feedback.')}</div>`;
          } else {
            html += `<div class="tiny">Avaliação automática indisponível.</div>`;
            if (r.feedback) { 
                 html += `<div class="explain result-wrong"><strong>Info:</strong> ${escapeHtml(r.feedback)}</div>`;
            }
            html += `<div class="explain"><strong>Resposta esperada:</strong> ${escapeHtml(r.question.answer || '—')}</div>`;
          }
        } else {
          if(r.correct){
            html += `<div class="result-correct">✔ Correto</div>`;
            if(r.explanation) {
                 html += `<div class="explain"><strong>Explicação:</strong> ${escapeHtml(r.explanation)}</div>`;
            }
          } else {
            html += `<div class="result-wrong">✖ Errado</div>`;
            html += `<div class="explain"><strong>Explicação:</strong> ${escapeHtml(r.explanation || '—')}</div>`;
          }
        }
        html += `</div>`;
      });
      html += `</div>`;
      html += `<div class="summary" style="margin-top:12px"><strong>Pontuação Final:</strong> ${correctCount} / ${results.length}</div>`;
      resultArea.innerHTML = html;
    }

    /* ---------- Timer ---------- */
    function startTimer(seconds){
      if(timerInterval) clearInterval(timerInterval);
      let s = seconds;
      function tick(){ const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); timerEl.textContent = `${mm}:${ss}`; if(s>0) s--; else clearInterval(timerInterval); }
      tick();
      timerInterval = setInterval(tick, 1000);
    }

    /* ---------- AI utils (CORRIGIDO para API Gemini) ---------- */
    async function callGenerativeAPI(apiKey, prompt) {
        const endpoint = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=' + encodeURIComponent(apiKey);
        const body = {
            contents: [ { parts: [{ "text": prompt }] } ],
            generationConfig: {
                temperature: 0.2,
                maxOutputTokens: 512,
                topK: 1,
                topP: 1
            }
        };
        const resp = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        if (!resp.ok) {
            const txt = await resp.text();
            throw new Error('API error: ' + resp.status + ' - ' + txt);
        }
        const j = await resp.json();
        try {
            const textOut = j.candidates[0].content.parts[0].text;
            return textOut;
        } catch (e) {
            console.error("Erro ao parsear resposta da API Gemini:", j);
            throw new Error('Formato de resposta inesperado da API.');
        }
    }

    function tryParseScoreFeedback(aiText){
      try{
        const jsonMatch = aiText.match(/\{[\s\S]*\}/);
        if(jsonMatch){
          const obj = JSON.parse(jsonMatch[0]);
          if(typeof obj.score !== 'undefined') {
              return { score: Number(obj.score), feedback: String(obj.feedback || '') };
          }
        }
      }catch(e){
          console.warn("Falha ao parsear JSON da IA:", e);
      }
      const scoreMatch = aiText.match(/score[:\s]*([0-9]+(?:\.[0-9]+)?)/i);
      if(scoreMatch){
        const s = Number(scoreMatch[1]);
        const fb = aiText.replace(scoreMatch[0],'').trim();
        return { score: s, feedback: fb };
      }
      console.warn("Não foi possível encontrar 'score' ou JSON na resposta da IA:", aiText);
      return null;
    }
    function buildEssayGradingPrompt(questionText, expectedAnswer, studentAnswer){
      return `Você é um avaliador especialista no assunto. Leia a questão e a resposta do aluno. Retorne apenas um JSON válido com o formato:
    {"score": NotaEntre0e10, "feedback": "comentários objetivos, pontos fortes e pontos a melhorar (curto)"}

    Questão:
    ${questionText}

    Resposta esperada (contexto):
    ${expectedAnswer}

    Resposta do aluno:
    ${studentAnswer}

    Avalie a resposta do aluno comparando com o esperado. Seja objetivo e devolva somente o JSON.`;
    }

    /* ---------- Init ---------- */
    (function init(){
      // pronto
    })();
  </script>
  
</body>
</html>
</body>
</html>
